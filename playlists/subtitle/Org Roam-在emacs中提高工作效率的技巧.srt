1
00:00:01.103 --> 00:00:03.335
orgrome 是用于编写

3
00:00:03.335 --> 00:00:04.487
和组织您的想法的出色工具，但是当

5
00:00:04.487 --> 00:00:06.623
您利用它提供的更多功能时，

7
00:00:06.623 --> 00:00:07.799
您可以为本视频

9
00:00:08.799 --> 00:00:10.104
中的常见任务创建高效的自定义工作流，

11
00:00:10.104 --> 00:00:12.120
我将向您展示五个

13
00:00:12.120 --> 00:00:13.138
技巧来优化您的笔记记录和

15
00:00:13.138 --> 00:00:15.152
使用

17
00:00:15.152 --> 00:00:17.175
orgrome 和 org 模式功能的项目管理工作流

19
00:00:17.175 --> 00:00:22.227
坚持学习更多，

21
00:00:22.227 --> 00:00:24.240
所以如果您喜欢这个视频，您可以

23
00:00:24.240 --> 00:00:25.252
通过单击下面的喜欢按钮来支持该频道，

25
00:00:25.252 --> 00:00:26.268
如果您还没有订阅，也可以订阅

27
00:00:26.268 --> 00:00:28.286
并查看

29
00:00:28.286 --> 00:00:30.300
下面的链接 描述更多

31
00:00:30.300 --> 00:00:31.310
支持频道的方法，如果

33
00:00:31.310 --> 00:00:33.334
您非常感兴趣，那么开始

35
00:00:33.334 --> 00:00:35.354
配置呃，在我们开始

37
00:00:35.354 --> 00:00:36.367
本视频中的所有内容之前，请确保

39
00:00:36.367 --> 00:00:38.388
您已经设置了 orgrome，您

41
00:00:38.388 --> 00:00:40.401
可以通过复制

43
00:00:40.401 --> 00:00:41.418
下面的配置快速开始这是

45
00:00:41.418 --> 00:00:43.436
每当您单击说明中的该链接时，也会在节目说明中，

47
00:00:43.436 --> 00:00:45.457
但是

49
00:00:45.457 --> 00:00:49.495
如果您首先观看 orgrome 系列中的以前的视频，您将了解更多信息，那就是

51
00:00:49.495 --> 00:00:51.509
用

53
00:00:51.509 --> 00:00:53.534
呃或铬构建第二个辫子在指向它们的链接之前有三个视频

55
00:00:53.534 --> 00:00:55.552
在这里 在展示

57
00:00:55.552 --> 00:00:57.569
说明中，然后我们有

59
00:00:57.569 --> 00:00:59.593
下面的配置，如果你想复制它，

61
00:00:59.593 --> 00:01:01.610
那么在这个视频中我将向

63
00:01:01.610 --> 00:01:03.630
你展示我编写的很多自定义代码

65
00:01:03.630 --> 00:01:04.648
来产生这些工作流程

67
00:01:04.648 --> 00:01:06.664
改进，如果你还没有的话 研究过

69
00:01:06.664 --> 00:01:08.687
emacs lisp，但其中一些代码可能

71
00:01:08.687 --> 00:01:11.713
不是 100 清楚，但没关系，别担心，

73
00:01:11.713 --> 00:01:14.740
我会尽力解释

75
00:01:14.740 --> 00:01:15.755
所有这些代码实际上应该被

77
00:01:15.755 --> 00:01:16.768
采用并放入您自己的

79
00:01:16.768 --> 00:01:18.782
配置中，以便您 只要它确实有效，就不需要真正

81
00:01:18.782 --> 00:01:21.815
了解它是如何工作的，

83
00:01:21.815 --> 00:01:23.831
但是如果您确实想了解

85
00:01:23.831 --> 00:01:24.846
这段代码的工作原理，我建议您

87
00:01:24.846 --> 00:01:27.873
更仔细地阅读代码并使用

89
00:01:27.873 --> 00:01:29.891
describe 函数和 describe 变量

91
00:01:29.891 --> 00:01:32.922
命令来阅读

93
00:01:32.922 --> 00:01:33.938
我在代码中使用的函数和变量的文档文档字符串你

95
00:01:33.938 --> 00:01:35.950
基本上可以浏览代码

97
00:01:35.950 --> 00:01:36.963
并将光标放在

99
00:01:36.963 --> 00:01:37.978
函数或变量之一上并使用 describe

101
00:01:37.978 --> 00:01:40.100
函数或 describe 变量然后

103
00:01:40.100 --> 00:01:41.101
你也可以观看我的学习 emacs

105
00:01:41.101 --> 00:01:43.103
列表 系列，如果你想有一个关于

107
00:01:43.103 --> 00:01:45.105
emacslist 的更完整的教程，这

109
00:01:45.105 --> 00:01:46.106
实际上可能会帮助你

111
00:01:46.106 --> 00:01:49.109
更好地了解这段代码的工作原理，

113
00:01:49.109 --> 00:01:50.110
但一如既往，请随时

115
00:01:50.110 --> 00:01:51.111
在评论中提出任何问题，我会

117
00:01:51.111 --> 00:01:53.113
尽力澄清

119
00:01:53.113 --> 00:01:56.115
你所拥有的和 也许我可以

121
00:01:56.115 --> 00:01:59.119
稍后在节目笔记中添加更多内容，好吧，

123
00:02:00.119 --> 00:02:01.121
有时当你写作时，第一次黑客攻击你

125
00:02:01.121 --> 00:02:03.123
会想要在你的 orgrome 笔记中创建一个新节点

127
00:02:03.123 --> 00:02:05.125
而不打断

129
00:02:05.125 --> 00:02:06.126
你的写作流程，所以让我们说你' 正在

131
00:02:06.126 --> 00:02:08.127
写一个关于特定主题的笔记，并且

133
00:02:08.127 --> 00:02:11.131
您想插入一个新链接到

135
00:02:11.131 --> 00:02:12.132
您的笔记中实际上还不存在的东西，但您不想

137
00:02:12.132 --> 00:02:14.134
真正写一些关于它的东西但

139
00:02:14.134 --> 00:02:15.135
您只想插入一个链接以便

141
00:02:15.135 --> 00:02:16.136
稍后您可以返回并填写该

143
00:02:16.136 --> 00:02:18.138
信息，

145
00:02:18.138 --> 00:02:20.140
通常用于插入指向

147
00:02:20.140 --> 00:02:23.143
您将使用 or chrome 节点插入

149
00:02:23.143 --> 00:02:25.145
命令的节点的链接，但是每当您使用

151
00:02:25.145 --> 00:02:26.146
此命令创建新节点时，就像您键入

153
00:02:26.146 --> 00:02:28.148
不存在的节点名称一样 但是

155
00:02:28.148 --> 00:02:30.149
它会在创建新笔记后打开它，

157
00:02:30.149 --> 00:02:31.151
这

159
00:02:31.151 --> 00:02:33.153
在您的工作流程中有点不和谐，因为您正在

161
00:02:33.153 --> 00:02:34.154
尝试写一些笔记，

163
00:02:34.154 --> 00:02:36.156
突然这个新缓冲区弹出这个新

165
00:02:36.156 --> 00:02:38.158
窗口弹出所以我们可以实际定义

167
00:02:38.158 --> 00:02:39.159
一个功能，可以让你创建一个

169
00:02:40.159 --> 00:02:42.162
新的笔记并插入一个链接而不用

171
00:02:42.162 --> 00:02:44.164
打开这个新的缓冲区，

173
00:02:44.164 --> 00:02:45.165
这将允许你

175
00:02:45.165 --> 00:02:47.167
快速创建新主题的笔记

177
00:02:47.167 --> 00:02:49.169
并且只需要写下那个链接

179
00:02:49.169 --> 00:02:50.170
然后返回它 稍后并在需要时

181
00:02:50.170 --> 00:02:52.172
填写更多信息

183
00:02:52.172 --> 00:02:54.174
所以我在这里有代码但是我们将

185
00:02:54.174 --> 00:02:55.175
跳到一个

187
00:02:56.175 --> 00:02:57.177
已经

189
00:02:57.177 --> 00:02:59.179
加载了这个功能的演示配置这是 orgrome

191
00:02:59.179 --> 00:03:01.181
node insert immediate 如果你曾经

193
00:03:01.181 --> 00:03:03.183
使用过 orgrome v1 你可能认得

195
00:03:04.183 --> 00:03:05.185
这个名字，因为曾经有一个

197
00:03:06.185 --> 00:03:07.187
功能，但他们把它拿出

199
00:03:07.187 --> 00:03:09.189
来简化或发展 v2，但我们

201
00:03:09.189 --> 00:03:11.191
现在要把它加回去所以这里的想法是，

203
00:03:11.191 --> 00:03:14.194
每当你在一个注释中时，让

205
00:03:14.194 --> 00:03:16.196
我们 在这里说方案说明你

207
00:03:16.196 --> 00:03:19.199
应该能够运行 um

209
00:03:19.199 --> 00:03:21.201
let's see or chrome

211
00:03:21.201 --> 00:03:23.202
insert immediate which i've bound to

213
00:03:23.202 --> 00:03:25.205
control c in capital i

215
00:03:25.205 --> 00:03:27.207
然后我应该能够

217
00:03:27.207 --> 00:03:29.209
像 python 一样在这里插入一个链接好吧，

219
00:03:29.209 --> 00:03:31.210
因为那个节点已经 存在但是

221
00:03:31.210 --> 00:03:32.212
如果我现在想插入

223
00:03:32.212 --> 00:03:34.214
类似 guile scheme 的东西怎么办

225
00:03:34.214 --> 00:03:36.216
如果我插入它只是

227
00:03:36.216 --> 00:03:38.217
直接在此缓冲区中插入指向该注释的链接

229
00:03:38.217 --> 00:03:39.219
而我实际上不必

231
00:03:39.219 --> 00:03:41.221
打开 geil scheme 节点然后

233
00:03:41.221 --> 00:03:43.223
对其进行编辑或添加 向

235
00:03:43.223 --> 00:03:45.225
它提供信息，但我始终可以

237
00:03:45.225 --> 00:03:47.227
通过 ctrl c ctrl o 转到该注释并在

239
00:03:47.227 --> 00:03:49.229
我准备好之后填写信息，

241
00:03:49.229 --> 00:03:50.230
这只是

243
00:03:50.230 --> 00:03:54.233
优化您的笔记工作流程的一种方式，

245
00:03:54.233 --> 00:03:56.236
好吧，这样 正在工作

247
00:03:56.236 --> 00:03:59.239
基本上我们正在使用您使用的现有

249
00:03:59.239 --> 00:04:02.242
orgrome 节点插入

251
00:04:02.242 --> 00:04:05.245
功能，但是我们

253
00:04:05.245 --> 00:04:07.247
使用包装它的 let 覆盖了一些功能，我们

255
00:04:07.247 --> 00:04:09.249
基本上覆盖了

257
00:04:09.249 --> 00:04:11.251
我们正在使用列表的 orgrome 捕获模板变量

259
00:04:11.251 --> 00:04:13.253
您已经拥有的捕获模板

261
00:04:13.253 --> 00:04:15.255
我们正在抓取第一项，

263
00:04:15.255 --> 00:04:18.258
所以

265
00:04:18.258 --> 00:04:20.259
如果您没有

267
00:04:20.259 --> 00:04:22.261
自定义或漫游捕获

269
00:04:22.261 --> 00:04:23.263
模板，那么基本上通常是列表第一项中的默认模板，并且开箱即用

271
00:04:23.263 --> 00:04:26.266
没问题，如果您自定义了

273
00:04:26.266 --> 00:04:27.267
您的组织漫游

275
00:04:27.267 --> 00:04:28.268
捕获模板，它将

277
00:04:28.268 --> 00:04:30.269
选择该列表中的第一个模板，因此只需

279
00:04:30.269 --> 00:04:31.271
确保

281
00:04:32.271 --> 00:04:33.273
该列表中的第一个模板是您的默认

283
00:04:33.273 --> 00:04:34.274
模板，没有任何额外的

285
00:04:34.274 --> 00:04:36.276
自定义

287
00:04:36.276 --> 00:04:38.278
这里的重要部分是

289
00:04:38.278 --> 00:04:40.279
添加到该模板的立即完成，

291
00:04:40.279 --> 00:04:41.281
我们正在添加这个立即完成 t

293
00:04:41.281 --> 00:04:43.283
它基本上告诉 chrome 和 org

295
00:04:44.283 --> 00:04:45.284
模式

297
00:04:45.284 --> 00:04:46.285
只

299
00:04:46.285 --> 00:04:48.287
创建这个新笔记而不显示

301
00:04:48.287 --> 00:04:50.289
捕获缓冲区并返回到

303
00:04:50.289 --> 00:04:51.291
你的内容 之前在做一些非常好的

305
00:04:52.291 --> 00:04:53.293
小技巧，让您的写作

307
00:04:53.293 --> 00:04:54.294
工作流程更加

309
00:04:54.294 --> 00:04:57.297
顺畅，所以现在您还可以

311
00:04:58.297 --> 00:05:00.300
从您的 orgrome 笔记中构建您的组织议程，以便

313
00:05:00.300 --> 00:05:01.301
在您

315
00:05:01.301 --> 00:05:03.302
进行项目

317
00:05:03.302 --> 00:05:05.305
计划或查看待办事项列表时提高工作效率，

319
00:05:05.305 --> 00:05:07.306
所以一个 org 模式最有用的功能之一

321
00:05:07.306 --> 00:05:09.308
是议程视图，您

323
00:05:09.308 --> 00:05:11.311
实际上可以使用您的或 chrome 笔记

325
00:05:11.311 --> 00:05:15.315
作为此视图的来源，而不必

327
00:05:15.315 --> 00:05:17.316
自己去配置此议程文件列表，您可以

329
00:05:17.316 --> 00:05:18.318
从 orgrome 列表中自动提取它们

331
00:05:18.318 --> 00:05:19.319
注意到你

333
00:05:20.319 --> 00:05:21.321
通常不会想要

335
00:05:21.321 --> 00:05:23.323
拉入所有的 orgrome 笔记，

337
00:05:23.323 --> 00:05:27.327
因为你的议程视图中的 org 文件越多，

339
00:05:27.327 --> 00:05:29.328
加载速度就越慢，所以我们希望尽量减少

341
00:05:29.328 --> 00:05:30.330
显示的笔记数量 在那里，实际上

343
00:05:30.330 --> 00:05:32.331
只是拉入那些必须

345
00:05:32.331 --> 00:05:35.334
做的项目，所以在这个例子中，如果你还记得我正在制作的 orgrom 系列的第二集，我们只会

347
00:05:35.334 --> 00:05:42.341
使用带有特定标签的笔记，比如项目

349
00:05:42.341 --> 00:05:44.343
我们制作了一个项目捕获模板，

351
00:05:44.343 --> 00:05:45.345
可以帮助您创建一个新项目，在

353
00:05:45.345 --> 00:05:47.347
该模板中，我们在项目文件上设置了一个标签，

355
00:05:48.347 --> 00:05:50.350
这样可以更容易地识别

357
00:05:50.350 --> 00:05:52.351
那些生效的地方，

359
00:05:52.351 --> 00:05:53.353
因为现在我们要

361
00:05:53.353 --> 00:05:56.355
查找所有这些 带有项目标签的笔记

363
00:05:56.355 --> 00:06:00.360
现在我必须输入我的 ssh 密钥

365
00:06:00.360 --> 00:06:02.361
然后我们将使用它们来

367
00:06:02.361 --> 00:06:04.364
构建我们的议程视图

369
00:06:04.364 --> 00:06:05.364
所以

371
00:06:05.364 --> 00:06:06.366
呃这是一个片段将找到

373
00:06:06.366 --> 00:06:09.368
所有带有特定标签的笔记然后

375
00:06:09.368 --> 00:06:11.370
设置你的组织议程列表

377
00:06:11.370 --> 00:06:12.372
带有相应注释文件的变量让我们

379
00:06:12.372 --> 00:06:14.374
跳到另一个屏幕，我可以向

381
00:06:14.374 --> 00:06:16.376
您展示它的外观所以我要

383
00:06:16.376 --> 00:06:18.378
调出这个 el 文件

385
00:06:18.378 --> 00:06:20.380
，嗯，

387
00:06:20.380 --> 00:06:22.382
到目前为止我还没有真正做到这一点

389
00:06:22.382 --> 00:06:25.384
所以让我调出 org agenda list

391
00:06:25.384 --> 00:06:26.385
variable

393
00:06:26.385 --> 00:06:28.387
agenda list

395
00:06:28.387 --> 00:06:30.390
oops an organ into files 我很抱歉，

397
00:06:30.390 --> 00:06:33.393
现在这是 nil 所以

399
00:06:34.393 --> 00:06:41.400
里面什么都没有

401
00:06:41.400 --> 00:06:43.403
我们定义的 list 命令将文件的来源设置为

403
00:06:43.403 --> 00:06:45.405
chrome list

405
00:06:45.405 --> 00:06:47.407
notes by tag 的结果，这是

407
00:06:47.407 --> 00:06:49.408
我们在这里定义的另一个功能，你

409
00:06:49.408 --> 00:06:51.410
基本上只需要传入一个标签名称，

411
00:06:51.410 --> 00:06:53.413
然后它就会

413
00:06:53.413 --> 00:06:55.414
查找

415
00:06:55.414 --> 00:06:56.416
所有 orgrome 节点文件，但它会

417
00:06:56.416 --> 00:06:58.418
过滤掉任何没有

419
00:06:58.418 --> 00:07:01.421
这个标签的文件，我们正在使用

421
00:07:01.421 --> 00:07:03.423
我们在这里编写的自定义过滤函数 orgrome

423
00:07:03.423 --> 00:07:05.424
按标签过滤，所以基本上它只

425
00:07:05.424 --> 00:07:06.426
返回一个过滤函数，寻找

427
00:07:06.426 --> 00:07:09.428
一个 特定标签，如果您过滤掉

429
00:07:09.428 --> 00:07:10.430
没有这些标签的笔记，

431
00:07:10.430 --> 00:07:12.431
您只会得到具有

433
00:07:12.431 --> 00:07:13.433
该特定标签的列表，

435
00:07:13.433 --> 00:07:16.436
所以如果我现在运行此功能，我的

437
00:07:16.436 --> 00:07:19.439
orgrome 议程刷新议程列表，

439
00:07:19.439 --> 00:07:22.442
我们可以去检查组织列表 agenda

441
00:07:22.442 --> 00:07:24.444
文件

443
00:07:24.444 --> 00:07:26.446
，现在我们可以看到

445
00:07:26.446 --> 00:07:28.448
这个列表中有几个不同的文件，如果我们

447
00:07:28.448 --> 00:07:32.452
要使用 meta x 运行 org agenda，它

449
00:07:32.452 --> 00:07:35.454
会首先询问我们想要哪个议程，

451
00:07:35.454 --> 00:07:37.456
我们可以按 a

453
00:07:37.456 --> 00:07:39.458
现在我们可以 看到这里有一个

455
00:07:39.458 --> 00:07:41.460
清洁院子的项目，如果你

457
00:07:41.460 --> 00:07:42.462
点击那个链接，它实际上会把我们带到

459
00:07:42.462 --> 00:07:45.464
我们的 orgrom 笔记中的杂务笔记，

461
00:07:45.464 --> 00:07:46.466
如果我们回到议程或者

463
00:07:46.466 --> 00:07:47.467
实际上让我们重新开始它

465
00:07:48.467 --> 00:07:51.470
org 议程并这次按 t 查看

467
00:07:51.470 --> 00:07:52.472
所有待办事项的列表，所以如果您想

469
00:07:52.472 --> 00:07:54.473
查看所有项目文件中的所有待办事项，

471
00:07:54.473 --> 00:07:57.476
请按 t 所以现在我们

473
00:07:57.476 --> 00:08:00.479
在这里有几件事，嗯，在

475
00:08:00.479 --> 00:08:01.481
我们的笔记中显示任务，但我们实际上会做

477
00:08:01.481 --> 00:08:03.482
更多 things

479
00:08:03.482 --> 00:08:04.484
在本视频的后面部分将任务添加到项目笔记中，这样

481
00:08:04.484 --> 00:08:06.485
我们就会看到更多的东西出现在那里

483
00:08:06.485 --> 00:08:07.487
所以重要的是看到

485
00:08:07.487 --> 00:08:10.490
我们可以拉入我们的 orgrom

487
00:08:10.490 --> 00:08:12.492
文件列表找到所有具有

489
00:08:12.492 --> 00:08:15.494
特定标签的笔记 然后将其设置到我们的

491
00:08:15.494 --> 00:08:17.496
议程列表中，这很好，因为您

493
00:08:17.496 --> 00:08:18.497
不必再​​考虑

495
00:08:18.497 --> 00:08:19.499
拥有哪些项目文件，只要

497
00:08:19.499 --> 00:08:21.500
您设置项目文件并确保

499
00:08:21.500 --> 00:08:23.502
它具有该项目标签并运行此

501
00:08:23.502 --> 00:08:27.506
功能即可 为你建立那个列表让我们

503
00:08:27.506 --> 00:08:28.508
看看

505
00:08:28.508 --> 00:08:30.510
这里还有什么有趣的东西

507
00:08:30.510 --> 00:08:33.513
哦是的好几件事所以

509
00:08:33.513 --> 00:08:35.515
首先我找不到一种可靠

511
00:08:35.515 --> 00:08:38.517
有效的方法来将每日笔记拉

513
00:08:38.517 --> 00:08:40.519
入议程视图但

515
00:08:40.519 --> 00:08:42.522
orgrom 中的底层代码用于

517
00:08:42.522 --> 00:08:45.524
查找 每日文件并不是

519
00:08:45.524 --> 00:08:47.526
为了在

521
00:08:47.526 --> 00:08:48.528
特定日期之后获取每日文件列表而制作的，这

523
00:08:48.528 --> 00:08:49.529
显然是可以

525
00:08:50.529 --> 00:08:51.530
编写的，它可以作为

527
00:08:51.530 --> 00:08:53.532
or grown 包的一部分编写，但它还不

529
00:08:53.532 --> 00:08:55.534
存在，所以如果我找到一种方法

531
00:08:55.534 --> 00:08:56.536
稍后我可能会更新节目

533
00:08:56.536 --> 00:08:58.538
说明或制作另一个视频，但

535
00:08:58.538 --> 00:08:59.539
我相信有人会想到

537
00:08:59.539 --> 00:09:01.540
你知道你如何将日常文件列入

539
00:09:01.540 --> 00:09:02.542
议程，我还没有一个好的

541
00:09:02.542 --> 00:09:03.543
答案但是 我们会

543
00:09:04.543 --> 00:09:05.544
在某个时候解决这个问题，

545
00:09:05.544 --> 00:09:07.546
这里要提到的另一件事

547
00:09:07.546 --> 00:09:09.548
你可能已经注意到了，之前每当

549
00:09:09.548 --> 00:09:13.553
我打开组织议程并显示待办事项列表时，

551
00:09:13.553 --> 00:09:15.554
一些文件

553
00:09:15.554 --> 00:09:16.556
可能看起来不太好，因为它们有

555
00:09:16.556 --> 00:09:18.557
时间戳在开头，因为

557
00:09:18.557 --> 00:09:21.560
这些项目文件在名称之前有一个时间戳，

559
00:09:21.560 --> 00:09:22.561
至少如果这是

561
00:09:22.561 --> 00:09:24.563
您配置或成长的方式，

563
00:09:24.563 --> 00:09:25.565
但我们可以通过

565
00:09:25.565 --> 00:09:29.568
向文件添加类别轻松清理它，所以如果我

567
00:09:29.568 --> 00:09:31.571
转到网格文件 我们在那里看到

569
00:09:31.571 --> 00:09:34.573
我们需要做的是下拉并添加

571
00:09:34.573 --> 00:09:37.576
一个名为 category 的新行，这

573
00:09:37.576 --> 00:09:38.578
实际上为文件设置了一个类别，

575
00:09:38.578 --> 00:09:41.580
但是 org agenda 使用它来

577
00:09:41.580 --> 00:09:43.583
显示名称，所以如果我再次拉回它，

579
00:09:43.583 --> 00:09:45.584
你现在可以看到 它说 mesh

581
00:09:45.584 --> 00:09:47.586
但它没有说文件名

583
00:09:47.586 --> 00:09:49.589
所以这里重要的是对于

585
00:09:49.589 --> 00:09:55.594
你的项目捕获模板，

587
00:09:55.594 --> 00:09:58.597
如果你看这里我有一个

589
00:09:58.597 --> 00:10:00.599
我们正在做的例子，你也会想要将该类别放入 在捕获

591
00:10:00.599 --> 00:10:02.601
模板中，我们有标题

593
00:10:02.601 --> 00:10:03.603
，然后是类别，它们

595
00:10:03.603 --> 00:10:06.605
都使用您为该

597
00:10:06.605 --> 00:10:09.608
笔记的名称输入的相同标题，所以如果

599
00:10:09.608 --> 00:10:11.611
您这样做，那么您所有笔记的名称

601
00:10:11.611 --> 00:10:13.612
将正确显示在

603
00:10:13.612 --> 00:10:14.613
议程视图 它只是您

605
00:10:14.613 --> 00:10:15.614
可能想知道的东西，如果您想让

607
00:10:15.614 --> 00:10:16.616
该视图看起来更清晰一点，并

609
00:10:16.616 --> 00:10:18.617
确切地知道

611
00:10:18.617 --> 00:10:22.621
您的所有 orgrom 任务都引用了哪些笔记 下

613
00:10:22.621 --> 00:10:24.624
一个 hack 从笔记列表中选择带有

615
00:10:24.624 --> 00:10:28.627
特定标签，因此

617
00:10:28.627 --> 00:10:31.631
我们绑定控制 cnf 的 orgrome 节点查找功能

619
00:10:31.631 --> 00:10:33.632
有点像

621
00:10:33.632 --> 00:10:35.634
我们用于导航到特定笔记的主要功能

623
00:10:35.634 --> 00:10:37.636
此功能使我们能够

625
00:10:37.636 --> 00:10:38.637
过滤

627
00:10:38.637 --> 00:10:40.639
显示以供选择的笔记列表，我们可以

629
00:10:40.639 --> 00:10:42.641
定义我们自己的函数，该函数显示

631
00:10:42.641 --> 00:10:43.643
具有特定标签的笔记的选择列表，

633
00:10:43.643 --> 00:10:45.644
就像我们在

635
00:10:45.644 --> 00:10:47.646
项目之前使用的那样，

637
00:10:47.646 --> 00:10:48.648
这对于设置

639
00:10:48.648 --> 00:10:50.650
键绑定以快速从一组

641
00:10:50.650 --> 00:10:53.652
特定的笔记中进行选择很有用，所以如果你想

643
00:10:53.652 --> 00:10:54.654
从你的任何项目笔记中选择，或者

645
00:10:54.654 --> 00:10:56.655
你可能想从

647
00:10:56.655 --> 00:10:58.657
你的参考笔记或任何其他

649
00:10:58.657 --> 00:11:00.659
笔记集中选择你可能设置了一个标签，我们

651
00:11:00.659 --> 00:11:01.661
可以创建一个功能来轻松地轻松获取

653
00:11:01.661 --> 00:11:03.663
这些笔记，

655
00:11:03.663 --> 00:11:05.664
所以一个额外的好处 对此

657
00:11:05.664 --> 00:11:07.666
非常有趣的是，我们

659
00:11:07.666 --> 00:11:08.668
实际上可以覆盖在创建

661
00:11:08.668 --> 00:11:10.669
新笔记时使用的捕获模板集，

663
00:11:10.669 --> 00:11:12.671
所以假设我们创建一个

665
00:11:12.671 --> 00:11:15.674
自定义函数，

667
00:11:15.674 --> 00:11:16.676
如果我们输入笔记的名称，它只会找到呃项目笔记

669
00:11:16.676 --> 00:11:18.677
还不存在我们可以我们将

671
00:11:18.677 --> 00:11:20.679
尝试从那个或 chrome 创建一个新的笔记

673
00:11:20.679 --> 00:11:22.681
我们将尝试从那个创建一个新的笔记

675
00:11:22.681 --> 00:11:24.683
但是我们可以覆盖

677
00:11:24.683 --> 00:11:25.685
在那里使用的捕获模板以

679
00:11:26.685 --> 00:11:27.687
自动默认为特定的

681
00:11:27.687 --> 00:11:29.689
项目模板节点 这样一来，

683
00:11:30.689 --> 00:11:33.692
如果您输入尚不存在的内容，您会自动获得一个新的项目节点，

685
00:11:33.692 --> 00:11:34.693
这很棒，

687
00:11:34.693 --> 00:11:37.696
所以让我们去尝试这段代码，

689
00:11:37.696 --> 00:11:38.698
我将

691
00:11:38.698 --> 00:11:40.700
在我们到达那里时详细解释它的作用，

693
00:11:40.700 --> 00:11:43.702
所以让我们回到 rom  .el

695
00:11:43.702 --> 00:11:45.705
和 um 我想我已经将它绑定到 uh

697
00:11:45.705 --> 00:11:47.706
让我们看看

699
00:11:47.706 --> 00:11:49.708
它绑定了什么 我认为它是

701
00:11:49.708 --> 00:11:58.718
p 中的 ctrl c

703
00:11:58.718 --> 00:12:00.719
现在它会问我

705
00:12:00.719 --> 00:12:02.721
要打开哪个项目，我们可以看到

707
00:12:02.721 --> 00:12:03.722
这些只是我拥有的三个节点，它们

709
00:12:03.722 --> 00:12:05.725
是项目节点

711
00:12:05.725 --> 00:12:09.728
所以嗯，我输入我可以吗，

713
00:12:09.728 --> 00:12:11.730
如果我想要的话，你知道选择系统工艺

715
00:12:11.730 --> 00:12:13.733
但是如果我再次使用控制 c 和 p 来

717
00:12:13.733 --> 00:12:17.736
寻找我可以在 youtube 中输入的项目，

719
00:12:17.736 --> 00:12:20.739
然后它会自动使用

721
00:12:20.739 --> 00:12:22.741
我指定的项目模板为这个项目创建一个新的捕获缓冲区，

723
00:12:22.741 --> 00:12:24.743
我可以在这里输入我想要的任何内容，

725
00:12:24.743 --> 00:12:26.746
只需按 ctrl c ctrl c，

727
00:12:26.746 --> 00:12:29.748
现在我有一个新项目，

729
00:12:29.748 --> 00:12:31.751
我在这种情况下在 youtube 中输入的名称，

731
00:12:32.751 --> 00:12:34.753
而且因为我将类别和

733
00:12:34.753 --> 00:12:36.756
文件标签放在这个文件中，这个文件

735
00:12:36.756 --> 00:12:39.759
将被设置为显示在我的议程中

737
00:12:40.759 --> 00:12:40.760
嗯，

739
00:12:40.760 --> 00:12:42.761
但是如果我们看一下代码，让我们

741
00:12:42.761 --> 00:12:44.763
试着理解这里发生了什么，

743
00:12:44.763 --> 00:12:46.765
所以让我们暂时跳过挂钩的事情，

745
00:12:46.765 --> 00:12:47.766
我会说我会在一秒钟内告诉你那是什么

747
00:12:47.766 --> 00:12:49.769
意思，所以最

749
00:12:49.769 --> 00:12:51.770
重要的是 事情是我们正在使用

751
00:12:51.770 --> 00:12:54.773
orgrome node find 命令，就像我在

753
00:12:54.773 --> 00:12:55.775
跳过前两个参数之前提到的那样，因为

755
00:12:55.775 --> 00:12:57.776
它们对于这个呃练习不是必需的，

757
00:12:57.776 --> 00:13:01.780
但我们确实通过我们之前提到的

759
00:13:01.780 --> 00:13:03.782
标记函数传递了 orgrome 过滤器的输出

761
00:13:03.782 --> 00:13:05.784
我们将尝试

763
00:13:05.784 --> 00:13:09.788
通过项目标签过滤该列表

765
00:13:09.788 --> 00:13:11.790
，然后我们在末尾有这个模板部分，

767
00:13:11.790 --> 00:13:13.792
我们说我们

769
00:13:13.792 --> 00:13:14.793
正在为此覆盖捕获

771
00:13:14.793 --> 00:13:17.796
模板集或增加节点查找

773
00:13:17.796 --> 00:13:18.797
执行

775
00:13:18.797 --> 00:13:20.800
以仅具有项目模板

777
00:13:20.800 --> 00:13:22.802
因为我们在这里只放了一个模板，这

779
00:13:22.802 --> 00:13:24.803
是默认选择的模板，

781
00:13:24.803 --> 00:13:25.804
所以我们不会收到

783
00:13:25.804 --> 00:13:27.806
选择哪个模板的提示，在这种情况下，它

785
00:13:27.806 --> 00:13:28.807
直接进入这个项目

787
00:13:28.807 --> 00:13:30.809
模板，嗯，

789
00:13:30.809 --> 00:13:31.810
基本上就是这样，无论何时

791
00:13:31.810 --> 00:13:32.812
你 输入一个不存在的项目的名称，

793
00:13:32.812 --> 00:13:34.813
它将创建一个全新的

795
00:13:34.813 --> 00:13:36.815
项目，这非常棒现在

797
00:13:36.815 --> 00:13:40.819
我们在这种情况下做的一件特别的事情是我们在

799
00:13:40.819 --> 00:13:43.822
这个函数的 finalize 钩子之后添加一个钩子或捕获 我们已经

801
00:13:43.822 --> 00:13:45.825
定义了名为 orgrome project finalize 的

803
00:13:45.825 --> 00:13:46.825
钩子，

805
00:13:46.825 --> 00:13:49.829
它实际上是将

807
00:13:49.829 --> 00:13:51.831
这个文件自动添加到

809
00:13:51.831 --> 00:13:54.834
议程文件集中，这样

811
00:13:54.834 --> 00:13:56.835
如果你创建一个新

813
00:13:56.835 --> 00:13:57.836
项目，你就不必再返回刷新议程文件列表了 这种方法会

815
00:13:57.836 --> 00:13:59.838
自动将其添加到您的议程

817
00:13:59.838 --> 00:14:00.840
文件中，如果我们现在去查看组织议程，请

819
00:14:00.840 --> 00:14:03.842
查看待办事项列表，

821
00:14:03.842 --> 00:14:04.843
我们会看到该待办事项已经

823
00:14:04.843 --> 00:14:06.846
在 youtube 中，嗯，注意，这是

825
00:14:06.846 --> 00:14:08.847
捕获模板的一部分 已经

827
00:14:08.847 --> 00:14:11.850
出现了，所以我们已经

829
00:14:11.850 --> 00:14:12.851
在我们的组织议程中出现了这个新项目，

831
00:14:12.851 --> 00:14:14.853
这非常酷

833
00:14:14.853 --> 00:14:16.855
这里要提到的其他几件事是

835
00:14:16.855 --> 00:14:19.858
我们将在调用此函数后立即将自己从钩子中移除，

837
00:14:19.858 --> 00:14:21.860
这样我们就不会 它不会

839
00:14:21.860 --> 00:14:23.862
永远存在，而且我们会检查

841
00:14:23.862 --> 00:14:24.864
以确保

843
00:14:24.864 --> 00:14:28.867
您正在捕获的笔记没有被中止，这样

845
00:14:28.867 --> 00:14:30.869
如果我们实际上取消了

847
00:14:30.869 --> 00:14:33.872
这个新笔记的捕获，我们就不会将这个文件添加到议程中所以

849
00:14:33.872 --> 00:14:33.872
呃

851
00:14:33.872 --> 00:14:35.874
我不会在那里做太多的细节，

853
00:14:35.874 --> 00:14:36.875
但你可以查看

855
00:14:36.875 --> 00:14:38.877
org note abort 等的文档来

857
00:14:38.877 --> 00:14:40.879
了解更多关于它是如何工作的，

859
00:14:40.879 --> 00:14:41.881
这里重要的是我们有一个

861
00:14:41.881 --> 00:14:43.882
简单的方法来从项目中选择并

863
00:14:43.882 --> 00:14:49.888
创建 如果该项目尚不存在，则在必要时创建一个新项目，

865
00:14:49.888 --> 00:14:51.890
因此下一个 hack 是

867
00:14:51.890 --> 00:14:52.891
简化

869
00:14:52.891 --> 00:14:55.895
任务和注释的自定义捕获，因此

871
00:14:56.895 --> 00:14:57.896
orgrome 提供了一个

873
00:14:57.896 --> 00:15:00.899
称为 org roam capture 的低级功能，末尾带有连字符，

875
00:15:00.899 --> 00:15:02.901
这实际上是故意的，我

877
00:15:02.901 --> 00:15:03.902
不确定到底是什么 为什么它被

879
00:15:03.902 --> 00:15:05.904
这样命名，但这就是它的命名方式，

881
00:15:05.904 --> 00:15:07.907
这允许您以非常灵活的方式调用 orgrom 的

883
00:15:08.907 --> 00:15:09.908
笔记捕获功能，

885
00:15:09.908 --> 00:15:11.910
您可以完全控制

887
00:15:11.910 --> 00:15:13.912
它发生的事情，您可以

889
00:15:13.912 --> 00:15:15.914
在 orgrim 手册的

891
00:15:15.914 --> 00:15:17.916
扩展部分下了解更多信息 捕获系统，

893
00:15:17.916 --> 00:15:19.918
因此我们实际上可以使用此功能来

895
00:15:19.918 --> 00:15:21.920
优化捕获

897
00:15:21.920 --> 00:15:23.922
工作流程的特定部分 这里有几种方法，

899
00:15:23.922 --> 00:15:24.923
我将向您展示如何

901
00:15:24.923 --> 00:15:25.924
使用它

903
00:15:25.924 --> 00:15:26.926
第一种是如果您想保留

905
00:15:26.926 --> 00:15:29.928
收件箱 笔记和任务，例如，

907
00:15:29.928 --> 00:15:31.930
如果您想快速将新笔记

909
00:15:31.930 --> 00:15:32.931
和任务捕获到 a 中，只需将一个键

911
00:15:32.931 --> 00:15:35.934
绑定到 s 中，

913
00:15:35.934 --> 00:15:37.936
您可以在稍后查看的地方像收件箱一样，您可以使用

915
00:15:37.936 --> 00:15:39.938
此功能捕获到特定

917
00:15:39.938 --> 00:15:40.939
文件

919
00:15:40.939 --> 00:15:42.941
um 和 即使这个文件

921
00:15:42.941 --> 00:15:44.943
前面没有时间戳文件名，

923
00:15:44.943 --> 00:15:45.944
前面也没有这些数字，

925
00:15:45.944 --> 00:15:46.946
它仍然会被创建为

927
00:15:46.946 --> 00:15:48.948
你的 orgrom 笔记中的一个节点，所以你

929
00:15:48.948 --> 00:15:51.950
可以使用控制 c 和 f 来找到

931
00:15:51.950 --> 00:15:54.953
我们使用此捕获模板创建的收件箱文件，

933
00:15:54.953 --> 00:15:56.955
因此我们要做的是定义一个

935
00:15:56.955 --> 00:15:59.959
名为或 chrome 捕获收件箱的函数，

937
00:16:00.959 --> 00:16:03.962
您可以在此处看到

939
00:16:03.962 --> 00:16:04.963
该

941
00:16:04.963 --> 00:16:05.964
函数将

943
00:16:05.964 --> 00:16:09.968
在末尾使用连字符调用 orgrome 捕获，并且 对于

945
00:16:09.968 --> 00:16:10.969
节点部分，我们将

947
00:16:10.969 --> 00:16:13.972
调用 orgro node create ，它

949
00:16:13.972 --> 00:16:14.973
实际上什么都不做，只是创建一个空白

951
00:16:14.973 --> 00:16:15.974
节点，

953
00:16:15.974 --> 00:16:17.976
然后对于模板列表，这是

955
00:16:17.976 --> 00:16:19.978
这里的重要部分，我们有一个

957
00:16:19.978 --> 00:16:21.980
名为 inbox 的模板，它纯粹只是

959
00:16:21.980 --> 00:16:24.983
创建 一个标题作为内容，

961
00:16:24.983 --> 00:16:26.985
然后文件名是 inbox.org，

963
00:16:26.985 --> 00:16:28.987
标题是收件箱，这只会被

965
00:16:28.987 --> 00:16:30.989
调用，或者

967
00:16:30.989 --> 00:16:32.991
只有当收件箱不存在时才会调用这个 inbox.work 部分，

969
00:16:32.991 --> 00:16:34.993
所以

971
00:16:34.993 --> 00:16:35.994
如果你没有收件箱 .org 文件，

973
00:16:35.994 --> 00:16:37.996
如果你有的话，

975
00:16:37.996 --> 00:16:39.998
它只是将这个新捕获的

977
00:16:39.998 --> 00:16:41.100
项目直接添加到那个收件箱文件中，所以这样

979
00:16:41.100 --> 00:16:44.100
做真的很快，

981
00:16:44.100 --> 00:16:45.100
嗯，

983
00:16:45.100 --> 00:16:47.100
让我们看看它的另一部分是什么

985
00:16:47.100 --> 00:16:49.100
，我们正在绑定这个 control c in b

987
00:16:50.100 --> 00:16:53.101
所以让我们看看当我在 b 中按下 control c 时会发生什么，

989
00:16:53.101 --> 00:16:54.101
当我这样做时它会拉出一个捕获

991
00:16:54.101 --> 00:16:56.101
缓冲区它只有一个星号用于

993
00:16:56.101 --> 00:16:59.101
此标题嗯这是我

995
00:16:59.101 --> 00:17:02.102
想记住我按 ctrl c ctrl 的注释 c

997
00:17:02.102 --> 00:17:03.102
然后它就完全消失了，所以这

999
00:17:03.102 --> 00:17:05.102
就像一发不可收拾的

1001
00:17:05.102 --> 00:17:07.102
捕获模板，你可以在其中创建

1003
00:17:07.102 --> 00:17:09.102
一个新的笔记，比如假设你正在做

1005
00:17:09.102 --> 00:17:10.102
一个项目，你想记住

1007
00:17:10.102 --> 00:17:11.103
一些你不想去想的事情 关于

1009
00:17:11.103 --> 00:17:13.103
你把它放在哪里，你只是想把

1011
00:17:13.103 --> 00:17:14.103
它放在某个地方，这样你

1013
00:17:14.103 --> 00:17:15.103
以后就可以把它直接捕获

1015
00:17:16.103 --> 00:17:17.103
到你的收件箱中，然后如果你使用

1017
00:17:17.103 --> 00:17:20.103
control cnf 并查找你的收件箱文件，

1019
00:17:20.103 --> 00:17:21.104
你可以返回并找到它 请

1021
00:17:21.104 --> 00:17:24.104
注意，已被捕获，您还可以

1023
00:17:24.104 --> 00:17:26.104
设置在此处执行您现在想做的任何事情，

1025
00:17:26.104 --> 00:17:28.104
显然，如果您使用的是 orgrome，则

1027
00:17:28.104 --> 00:17:29.104
可能有更有效的方法可以

1029
00:17:29.104 --> 00:17:31.105
快速将事物捕获到

1031
00:17:31.105 --> 00:17:33.105
您关心的笔记中，但如果您想要

1033
00:17:33.105 --> 00:17:34.105
一个 收件箱如果这是您

1035
00:17:34.105 --> 00:17:36.105
工作流程的一部分，那么这是一种非常简单的方法来

1037
00:17:36.105 --> 00:17:37.105
设置其中一个以

1039
00:17:37.105 --> 00:17:40.105
供您将来使用

1041
00:17:40.105 --> 00:17:41.106
接下来我发现

1043
00:17:41.106 --> 00:17:43.106
更有趣的事情是将任务

1045
00:17:43.106 --> 00:17:45.106
直接捕获到特定项目中，所以如果

1047
00:17:46.106 --> 00:17:47.106
您 设置一个项目 如果您设置了

1049
00:17:47.106 --> 00:17:48.106
我们

1051
00:17:48.106 --> 00:17:50.106
在本视频前面讨论过的项目注释文件，您

1053
00:17:50.106 --> 00:17:51.107
可以设置一个捕获模板，该模板

1055
00:17:51.107 --> 00:17:54.107
允许您快速捕获

1057
00:17:54.107 --> 00:17:56.107
任何存在或可能不

1059
00:17:56.107 --> 00:17:58.107
存在的项目的任务 像以前一样，我们可以

1061
00:17:58.107 --> 00:18:00.107
选择一个存在或

1063
00:18:00.107 --> 00:18:04.108
不存在的项目，如果它不存在，它将

1065
00:18:04.108 --> 00:18:06.108
在该任务被捕获之前创建，所以它非常强大，

1067
00:18:06.108 --> 00:18:08.108
就像您有一个需要处理的新项目一样

1069
00:18:08.108 --> 00:18:11.108
你还没有注释，但你

1071
00:18:11.108 --> 00:18:12.109
可以运行这个捕获模板来为它创建一个

1073
00:18:12.109 --> 00:18:13.109
任务，它会

1075
00:18:13.109 --> 00:18:16.109
先创建项目注释，然后将任务添加

1077
00:18:16.109 --> 00:18:18.109
到其中，这真的很酷，很快，

1079
00:18:18.109 --> 00:18:21.110
所以我们有 这里的代码我将

1081
00:18:21.110 --> 00:18:24.110
再次跳转到这个文件捕获任务它就

1083
00:18:24.110 --> 00:18:26.110
在那里

1085
00:18:26.110 --> 00:18:28.110
所以呃让我们先运行它我想我已经

1087
00:18:28.110 --> 00:18:31.111
绑定到控制 cnt

1089
00:18:31.111 --> 00:18:33.111
并且我们在这里看到我们的项目列表

1091
00:18:33.111 --> 00:18:34.111
youtube 项目 有没有我们

1093
00:18:34.111 --> 00:18:36.111
之前创建的，

1095
00:18:36.111 --> 00:18:37.111
呃让我们

1097
00:18:37.111 --> 00:18:39.111
看看我如何创建一个

1099
00:18:39.111 --> 00:18:42.112
名为呃视频的新项目

1101
00:18:42.112 --> 00:18:43.112
现在我们有一个捕获缓冲区已经

1103
00:18:43.112 --> 00:18:45.112
为我们开始了待办事项我

1105
00:18:45.112 --> 00:18:48.112
可以说呃记录下一个视频

1107
00:18:48.112 --> 00:18:50.112
和嗯一件事 您可能不知道

1109
00:18:50.112 --> 00:18:51.113
这些捕获模板是您可以根据

1111
00:18:51.113 --> 00:18:53.113
需要继续添加任务所以如果我

1113
00:18:53.113 --> 00:18:55.113
在此处按 alt enter 或实际控制

1115
00:18:55.113 --> 00:18:57.113
yeah ctrl alt enter 我可以放入另一个

1117
00:18:57.113 --> 00:18:59.113
任务所以如果您想捕获

1119
00:18:59.113 --> 00:19:00.113
多个任务我可以 项目你可以很

1121
00:19:00.113 --> 00:19:02.114
容易地做到这一点让我们

1123
00:19:02.114 --> 00:19:03.114
看看计划

1125
00:19:03.114 --> 00:19:05.114
另一个视频让我们说现在我已经

1127
00:19:05.114 --> 00:19:07.114
准备好将这些东西捕获到

1129
00:19:07.114 --> 00:19:10.114
文件中如果我按 ctrl c ctrl c

1131
00:19:10.114 --> 00:19:13.115
捕获模板视图消失

1133
00:19:13.115 --> 00:19:14.115
我们已经恢复了那些那些任务 我们可以

1135
00:19:14.115 --> 00:19:16.115
回到我们正在做的任何事情然后

1137
00:19:16.115 --> 00:19:18.115
如果我们想去看看那个文件

1139
00:19:18.115 --> 00:19:21.116
控制 cnf 我去视频

1141
00:19:21.116 --> 00:19:23.116
我们可以看到有一个任务条目然后

1143
00:19:23.116 --> 00:19:25.116
我们有我们

1145
00:19:25.116 --> 00:19:27.116
在这里捕获的待办事项我注意到 我犯的一个错误

1147
00:19:27.116 --> 00:19:30.116
是我应该放

1149
00:19:30.116 --> 00:19:33.117
两个标题级别，但事实上

1151
00:19:33.117 --> 00:19:35.117
我们把它放到了一个不存在的文件中，

1153
00:19:35.117 --> 00:19:37.117
现在已经创建了，这

1155
00:19:37.117 --> 00:19:39.117
很好，我们也自动添加了

1157
00:19:39.117 --> 00:19:42.118
这个任务部分，然后 从

1159
00:19:42.118 --> 00:19:44.118
um

1161
00:19:44.118 --> 00:19:46.118
捕获模板，所以如果我们查看

1163
00:19:46.118 --> 00:19:48.118
orgrim 捕获任务函数，我们将

1165
00:19:48.118 --> 00:19:51.119
像以前一样使用 orgrome 捕获连字符，然后

1167
00:19:51.119 --> 00:19:54.119
如果我们转到

1169
00:19:54.119 --> 00:19:55.119
模板部分，

1171
00:19:55.119 --> 00:19:57.119
我们可以查看此处

1173
00:19:58.119 --> 00:19:59.119
要执行的输入，我应该 实际上将

1175
00:19:59.119 --> 00:20:03.120
其固定为二级标题，

1177
00:20:03.120 --> 00:20:04.120
然后

1179
00:20:04.120 --> 00:20:05.120
我们在这里使用的一件事

1181
00:20:05.120 --> 00:20:06.120
与

1183
00:20:06.120 --> 00:20:07.120
我们之前看到的以前的捕获模板不同，我们

1185
00:20:08.120 --> 00:20:09.120
使用的是文件加头，而不是文件加头，

1187
00:20:09.120 --> 00:20:12.121
我们使用文件加头加 olp

1189
00:20:12.121 --> 00:20:15.121
这意味着嗯，这

1191
00:20:15.121 --> 00:20:16.121
就像我猜你可以称它为一个

1193
00:20:16.121 --> 00:20:18.121
函数，但它并不是一个真正的函数，它

1195
00:20:18.121 --> 00:20:19.121
有两个参数，而不是

1197
00:20:19.121 --> 00:20:21.122
两个参数，它现在有三个参数，第三个

1199
00:20:21.122 --> 00:20:23.122
参数是

1201
00:20:23.122 --> 00:20:25.122
这个新项目

1203
00:20:26.122 --> 00:20:27.122
被捕获的标题所以 在这种情况下，我们

1205
00:20:27.122 --> 00:20:29.122
说的是顶级

1207
00:20:30.122 --> 00:20:31.123
标题的任务，但即使你想做

1209
00:20:31.123 --> 00:20:33.123
一些类似二级或三级

1211
00:20:33.123 --> 00:20:35.123
标题的事情，你也可以说

1213
00:20:35.123 --> 00:20:37.123
呃项目任务，这就像

1215
00:20:37.123 --> 00:20:39.123
你插入东西的层次结构

1217
00:20:39.123 --> 00:20:41.123
但是 为了我们的目的，我们将

1219
00:20:41.123 --> 00:20:42.124
它插入一个名为

1221
00:20:42.124 --> 00:20:44.124
任务的标题下，如果该标题

1223
00:20:44.124 --> 00:20:46.124
不存在，捕获模板

1225
00:20:46.124 --> 00:20:48.124
将在该文件中创建它，因此它

1227
00:20:48.124 --> 00:20:50.124
为我们自动创建了很多过程，用于实际

1229
00:20:50.124 --> 00:20:52.125
创建一个新的笔记文件创建一个任务

1231
00:20:52.125 --> 00:20:55.125
它进入那个笔记文件，嗯，

1233
00:20:55.125 --> 00:20:57.125
现在把它放在正确的标题下，

1235
00:20:57.125 --> 00:21:00.125
如果我们再次运行这个控制 cnt，我可以

1237
00:21:00.125 --> 00:21:03.126
再次选择视频，然后我可以说

1239
00:21:03.126 --> 00:21:05.126
让我再做一个 哎呀，让我

1241
00:21:05.126 --> 00:21:06.126
做这个呃另一个二级

1243
00:21:06.126 --> 00:21:08.126
标题呃

1245
00:21:08.126 --> 00:21:10.126
嗯，让我们看看

1247
00:21:10.126 --> 00:21:12.127
呃删除频道那个

1249
00:21:12.127 --> 00:21:15.127
ctrl c ctrl c 怎么样，它实际上

1251
00:21:15.127 --> 00:21:17.127
进入那个呃视频注意我可以

1253
00:21:17.127 --> 00:21:19.127
拉回哎呀我可以用

1255
00:21:19.127 --> 00:21:21.128
控制 cnf 视频拉回

1257
00:21:21.128 --> 00:21:23.128
然后我们有这个呃新的

1259
00:21:23.128 --> 00:21:25.128
删除频道 出现了，嗯，我认为

1261
00:21:25.128 --> 00:21:26.128
模板现在坏了，

1263
00:21:26.128 --> 00:21:28.128
但是删除通道确实被添加到

1265
00:21:28.128 --> 00:21:29.128
它应该在的地方，这

1267
00:21:29.128 --> 00:21:32.129
太棒了，所以

1269
00:21:32.129 --> 00:21:33.129
如果笔记已经存在，它就会

1271
00:21:33.129 --> 00:21:35.129
被放入现有的笔记中，但如果它

1273
00:21:35.129 --> 00:21:36.129
还不存在 它将首先创建它，

1275
00:21:36.129 --> 00:21:38.129
然后将该捕获任务

1277
00:21:38.129 --> 00:21:41.130
放入笔记中，这真的很酷，

1279
00:21:41.130 --> 00:21:43.130
所以我认为这就是

1281
00:21:43.130 --> 00:21:45.130
我们想在那里说的一切，嗯

1283
00:21:45.130 --> 00:21:47.130
，同样的事情也适用于这里我们在

1285
00:21:47.130 --> 00:21:51.131
完成钩子之后有用于组织捕获的钩子

1287
00:21:51.131 --> 00:21:54.131
如果它实际上是

1289
00:21:54.131 --> 00:21:57.131
一个新文件，则在创建文件后将其放入议程，这很好，

1291
00:21:57.131 --> 00:22:00.131
并且该视频的最后一个技巧

1293
00:22:00.131 --> 00:22:01.132
是嗯

1295
00:22:01.132 --> 00:22:03.132
，日常文件有一个有趣的用途，

1297
00:22:03.132 --> 00:22:05.132
呃，我们还没有

1299
00:22:05.132 --> 00:22:06.132
真正考虑过哪个 是

1301
00:22:06.132 --> 00:22:08.132
保留在特定日期完成的任务的日志，

1303
00:22:08.132 --> 00:22:10.132
所以如果我们可以

1305
00:22:10.132 --> 00:22:13.133
自动将任何组织模式文件中已完成的任务复制

1307
00:22:13.133 --> 00:22:15.133
到今天的日常文件中，

1309
00:22:15.133 --> 00:22:17.133
那么它可能是甚至不

1311
00:22:17.133 --> 00:22:18.133
属于您或漫游笔记的组织文件，但是 我们

1313
00:22:18.133 --> 00:22:21.134
可以将它们复制到您的日常文件中，

1315
00:22:21.134 --> 00:22:23.134
所以也许您想将其保存为

1317
00:22:23.134 --> 00:22:25.134
发生的事情的日志，嗯，现在

1319
00:22:25.134 --> 00:22:26.134
有人可能会说，哦，您可以只使用

1321
00:22:26.134 --> 00:22:28.134
您的组织议程，这是真的，

1323
00:22:28.134 --> 00:22:30.134
但这是如果您每天对待 文件

1325
00:22:30.134 --> 00:22:33.135
更像是特定日期发生的事情的历史记录，

1327
00:22:33.135 --> 00:22:34.135
那么

1329
00:22:34.135 --> 00:22:35.135
不需要生成该文件这是

1331
00:22:35.135 --> 00:22:37.135
已经存在的东西，因此将

1333
00:22:37.135 --> 00:22:38.135
那些已完成的任务复制到它可能

1335
00:22:38.135 --> 00:22:40.135
会很好，所以我们实际上可以

1337
00:22:40.135 --> 00:22:42.136
通过添加来完成此操作 一些自定义

1339
00:22:42.136 --> 00:22:44.136
代码和下面的代码片段

1341
00:22:44.136 --> 00:22:47.136
为所有组织模式任务状态更改设置了一个挂钩，

1343
00:22:47.136 --> 00:22:49.136
以便从 to do 更改为

1345
00:22:49.136 --> 00:22:51.137
done 或任何其他状态，然后将已

1347
00:22:51.137 --> 00:22:53.137
更改为 done 的任何已完成任务复制

1349
00:22:53.137 --> 00:22:56.137
到今天的每日

1351
00:22:56.137 --> 00:22:58.137
笔记文件中，

1353
00:22:58.137 --> 00:22:59.137
并且 这

1355
00:22:59.137 --> 00:23:03.138
比前面的例子稍微复杂一点，所以每当

1357
00:23:03.138 --> 00:23:06.138
我们看到它是如何工作的时候，我都会尝试逐步完成一点，

1359
00:23:06.138 --> 00:23:08.138
所以嗯，

1361
00:23:08.138 --> 00:23:10.138
我真正需要做的就是

1363
00:23:10.138 --> 00:23:12.139
跳入一个文件，所以让我们说 控制

1365
00:23:12.139 --> 00:23:15.139
cnf uh 方案，

1367
00:23:15.139 --> 00:23:17.139
我必须在这里做学习方案

1369
00:23:17.139 --> 00:23:20.139
所以如果我只是使用 uh shift right 并将

1371
00:23:20.139 --> 00:23:21.140
其设置为完成然后

1373
00:23:21.140 --> 00:23:24.140
我可以转到我的 uh 每日笔记文件

1375
00:23:24.140 --> 00:23:26.140
所以控制 c n d d

1377
00:23:26.140 --> 00:23:29.140
我们看到学习方案现在在这里

1379
00:23:29.140 --> 00:23:31.141
所以 我们实际上将此任务复制到

1381
00:23:31.141 --> 00:23:33.141
每日文件中，以显示

1383
00:23:33.141 --> 00:23:35.141
我们今天完成此任务的任务列表，

1385
00:23:35.141 --> 00:23:36.141
因此，如果您返回此

1387
00:23:36.141 --> 00:23:38.141
每日笔记，您会看到您

1389
00:23:38.141 --> 00:23:39.141
在

1391
00:23:39.141 --> 00:23:42.142
9 月 13 日学习了计划，这有点像 很好，

1393
00:23:42.142 --> 00:23:45.142
嗯，还有任何其他任务，所以让我们看看

1395
00:23:45.142 --> 00:23:48.142
我是否转到一个文件，

1397
00:23:48.142 --> 00:23:51.142
嗯，我会打开它来做

1399
00:23:51.142 --> 00:23:52.143
这不是我的 orgrome 笔记的一部分，这

1401
00:23:52.143 --> 00:23:54.143
只是一个名为 test.org 的文件，它在我的

1403
00:23:54.143 --> 00:23:55.143
主文件夹中，

1405
00:23:55.143 --> 00:23:57.143
如果我 将其更改为完成

1407
00:23:57.143 --> 00:23:59.143
让我们先去吧 哎呀 让我们先回到

1409
00:23:59.143 --> 00:24:03.144
今天的日常文件

1411
00:24:03.144 --> 00:24:06.144
该任务现在不在这里 好吧所以

1413
00:24:06.144 --> 00:24:07.144
我要切换回 test.org 我

1415
00:24:07.144 --> 00:24:09.144
要使用 shift uh left arrow to

1417
00:24:09.144 --> 00:24:10.144
完成它

1419
00:24:10.144 --> 00:24:12.145
然后我要跳回到我的日常

1421
00:24:12.145 --> 00:24:14.145
文件，现在看到这是一个测试

1423
00:24:14.145 --> 00:24:15.145
现在已经移到这里有趣

1425
00:24:15.145 --> 00:24:17.145
的是它实际上被放在

1427
00:24:17.145 --> 00:24:19.145
正确的标题级别这是两颗星

1429
00:24:19.145 --> 00:24:20.145
在这里但原始文件是 实际上是

1431
00:24:20.145 --> 00:24:23.146
一颗星标题级别，所以我们使用一个

1433
00:24:23.146 --> 00:24:25.146
名为 org refile 的命令来

1435
00:24:25.146 --> 00:24:27.146
为我们处理这个，它很聪明，它

1437
00:24:27.146 --> 00:24:29.146
有点理解 org 文件中的上下文，

1439
00:24:29.146 --> 00:24:33.147
并且可以以非常干净的方式移动任务或复制任务

1441
00:24:33.147 --> 00:24:35.147
必要的元数据和

1443
00:24:35.147 --> 00:24:36.147
内容，

1445
00:24:36.147 --> 00:24:37.147
所以让我们快速看一下代码，

1447
00:24:37.147 --> 00:24:39.147
看看我们是否能理解

1449
00:24:39.147 --> 00:24:40.147
它是如何工作的，

1451
00:24:40.147 --> 00:24:43.148
所以首先我们在

1453
00:24:43.148 --> 00:24:46.148
执行状态更改挂钩之后向组织添加一个函数，

1455
00:24:46.148 --> 00:24:48.148
这是一个挂钩，呃 每当

1457
00:24:48.148 --> 00:24:50.148
a to do 状态更改时运行，

1459
00:24:50.148 --> 00:24:52.149
呃，我们将

1461
00:24:52.149 --> 00:24:54.149
首先检查当前任务的状态是否

1463
00:24:54.149 --> 00:24:57.149
已完成，因此每当此

1465
00:24:57.149 --> 00:24:59.149
挂钩运行时，此 org 状态变量将

1467
00:24:59.149 --> 00:25:01.149
设置为该任务的任何状态

1469
00:25:01.149 --> 00:25:03.150
，然后 如果完成了，我们

1471
00:25:03.150 --> 00:25:04.150
将

1473
00:25:04.150 --> 00:25:07.150
运行这个 myorgrome copy to do today

1475
00:25:07.150 --> 00:25:09.150
函数，它在这里定义，

1477
00:25:09.150 --> 00:25:11.151
所以在这个函数中发生的

1479
00:25:11.151 --> 00:25:13.151
是

1481
00:25:13.151 --> 00:25:15.151
我们设置了一些变量来覆盖某些

1483
00:25:15.151 --> 00:25:16.151
功能，这就是事情

1485
00:25:16.151 --> 00:25:18.151
变得有点复杂的地方，所以 呃，

1487
00:25:18.151 --> 00:25:21.151
我们正在重写 orgrome 日报捕获

1489
00:25:21.151 --> 00:25:23.152
模板，我们实际上要

1491
00:25:23.152 --> 00:25:25.152
在这里创建一个内联模板，用于

1493
00:25:25.152 --> 00:25:29.152
捕获到今天日期的任务，所以这

1495
00:25:29.152 --> 00:25:31.153
是一个每日文件，我们可以看到我们有

1497
00:25:31.153 --> 00:25:33.153
今天

1499
00:25:33.153 --> 00:25:36.153
日期和标题的每日格式 也是一样的，

1501
00:25:36.153 --> 00:25:38.153
我们使用这个文件加上

1503
00:25:38.153 --> 00:25:39.153
我之前提到的 head 和 olp 把它放在

1505
00:25:39.153 --> 00:25:42.154
任务标题下，所以

1507
00:25:42.154 --> 00:25:44.154
我们接下来要做的

1509
00:25:44.154 --> 00:25:45.154
是

1511
00:25:45.154 --> 00:25:47.154
设置一个挂钩，用于在我们重新填充之后保存

1513
00:25:47.154 --> 00:25:49.154
缓冲区 为了确保

1515
00:25:49.154 --> 00:25:51.154
该缓冲区不会以修改

1517
00:25:51.154 --> 00:25:53.155
状态结束，也许您知道 emacs 崩溃或

1519
00:25:53.155 --> 00:25:54.155
您的计算机崩溃并且您丢失了该

1521
00:25:54.155 --> 00:25:55.155
信息您肯定想

1523
00:25:55.155 --> 00:25:57.155
确保该信息被保存并且我们还创建了

1525
00:25:57.155 --> 00:25:59.155
一些其他变量

1527
00:25:59.155 --> 00:26:02.156
我们也设置了 org  file keep to true 并且

1529
00:26:02.156 --> 00:26:06.156
它的作用是它将任务

1531
00:26:06.156 --> 00:26:08.156
从原始位置复制到

1533
00:26:08.156 --> 00:26:09.156
目标位置它实际上并没有

1535
00:26:09.156 --> 00:26:12.157
复制它它只是告诉 orgrim 文件

1537
00:26:12.157 --> 00:26:14.157
复制它如果你将它设置为 nil 而不是

1539
00:26:14.157 --> 00:26:15.157
它会移动任务 如果你想

1541
00:26:16.157 --> 00:26:17.157
移动它们，

1543
00:26:17.157 --> 00:26:19.157
那么我们在设置这些变量之后做的下一件事

1545
00:26:19.157 --> 00:26:20.157
就是我们调用

1547
00:26:20.157 --> 00:26:23.158
保存窗口偏移，这基本上

1549
00:26:23.158 --> 00:26:26.158
只是告诉 emacs 在这个

1551
00:26:26.158 --> 00:26:27.158
保存窗口偏移的调用中没问题，我

1553
00:26:27.158 --> 00:26:29.158
要做一些事情 但是一旦

1555
00:26:29.158 --> 00:26:31.158
完成，我希望你将所有

1557
00:26:31.158 --> 00:26:32.159
窗口状态设置回之前的状态，

1559
00:26:32.159 --> 00:26:34.159
这样用户甚至不会意识到

1561
00:26:34.159 --> 00:26:36.159
发生了什么，否则

1563
00:26:36.159 --> 00:26:37.159
我们调用的这些函数

1565
00:26:37.159 --> 00:26:39.159
实际上会改变窗口

1567
00:26:39.159 --> 00:26:41.159
状态，它会 惹恼用户，

1569
00:26:41.159 --> 00:26:43.160
所以在这个函数中我们将

1571
00:26:43.160 --> 00:26:48.160
调用 orgrome dailies capture，它

1573
00:26:48.160 --> 00:26:50.160
使用这个模板调用每日捕获，我们实际上

1575
00:26:50.160 --> 00:26:52.161
为 dailies 捕获模板覆盖它

1577
00:26:52.161 --> 00:26:54.161
然后嗯

1579
00:26:54.161 --> 00:26:57.161
它正在做的是

1581
00:26:57.161 --> 00:26:59.161
第二个参数实际上说

1583
00:26:59.161 --> 00:27:01.161
与其使用捕获模板创建内容，

1585
00:27:01.161 --> 00:27:03.162
不如跳转到

1587
00:27:03.162 --> 00:27:05.162
该缓冲区中的位置，我们

1589
00:27:05.162 --> 00:27:06.162
现在要做的是获取缓冲区文件名，因为

1591
00:27:06.162 --> 00:27:08.162
我们实际上无法提前知道

1593
00:27:08.162 --> 00:27:09.162
缓冲区文件名是什么，

1595
00:27:09.162 --> 00:27:10.162
因为 捕获系统现在必须创建

1597
00:27:10.162 --> 00:27:13.163
它，因为我们在运行捕获后位于该文件中，

1599
00:27:13.163 --> 00:27:15.163
我们可以运行缓冲区文件

1601
00:27:15.163 --> 00:27:17.163
名来获取文件名并获取

1603
00:27:17.163 --> 00:27:20.163
文件中的位置，然后我们

1605
00:27:20.163 --> 00:27:21.164
退出该文件，但在此之前我们

1607
00:27:22.164 --> 00:27:24.164
设置了这些 两个带有该信息的变量

1609
00:27:24.164 --> 00:27:27.164
，现在我们可以使用该信息将

1611
00:27:27.164 --> 00:27:30.164
任务重新归档到

1613
00:27:30.164 --> 00:27:32.165
原始缓冲区中的当前位置，我们

1615
00:27:32.165 --> 00:27:34.165
在新

1617
00:27:34.165 --> 00:27:36.165
捕获的条目中的那个位置，所以这有点

1619
00:27:36.165 --> 00:27:38.165
复杂我知道我的解释

1621
00:27:38.165 --> 00:27:39.165
可能不会为

1623
00:27:39.165 --> 00:27:40.165
每个人澄清它，所以

1625
00:27:40.165 --> 00:27:42.166
如果您

1627
00:27:42.166 --> 00:27:43.166
想了解它是如何工作的，请仔细查看这段代码，但

1629
00:27:43.166 --> 00:27:45.166
正如您所看到的，

1631
00:27:45.166 --> 00:27:47.166
只要我更改待办事项的状态，它就会自动运行，

1633
00:27:47.166 --> 00:27:48.166
它会被复制过来 你

1635
00:27:48.166 --> 00:27:50.166
不需要做任何事情，所有东西都会

1637
00:27:50.166 --> 00:27:52.167
自己保存，你会

1639
00:27:52.167 --> 00:27:54.167
永远记录这些信息，所以这是一个非常

1641
00:27:54.167 --> 00:27:56.167
酷的小技巧，我花了

1643
00:27:56.167 --> 00:27:58.167
一点时间来拨入正确的

1645
00:27:58.167 --> 00:28:00.167
东西来完成这项工作，但

1647
00:28:00.167 --> 00:28:02.168
我 我对它的结果很满意

1649
00:28:02.168 --> 00:28:02.168
所以非常

1651
00:28:02.168 --> 00:28:05.168
酷

1653
00:28:05.168 --> 00:28:06.168
所以我

1655
00:28:06.168 --> 00:28:07.168
在这里有更多关于它如何工作的细节可能

1657
00:28:08.168 --> 00:28:09.168
它和我刚才说的一样但是

1659
00:28:09.168 --> 00:28:10.168
你可以看一下并阅读

1661
00:28:10.168 --> 00:28:12.169
如果你想

1663
00:28:12.169 --> 00:28:14.169
好，那么最后的配置呃，在

1665
00:28:14.169 --> 00:28:16.169
我们向你展示了这里的五个技巧之后，呃，

1667
00:28:16.169 --> 00:28:19.169
你可以在最后使用这段代码，

1669
00:28:19.169 --> 00:28:20.169
如果你想尝试所有这些，你可以将它复制并粘贴到你的配置中

1671
00:28:20.169 --> 00:28:23.170
但这里有一个非常

1673
00:28:23.170 --> 00:28:25.170
重要的注意事项，无论

1675
00:28:25.170 --> 00:28:27.170
你把这段代码放在什么文件中，如果

1677
00:28:27.170 --> 00:28:30.170
它是你的 init.el 或其他一些 e-lisp

1679
00:28:30.170 --> 00:28:31.171
文件，你需要确保你的

1681
00:28:31.171 --> 00:28:33.171
文件的第一行有这个词法

1683
00:28:34.171 --> 00:28:35.171
绑定 t

1685
00:28:35.171 --> 00:28:37.171
变量集 在其中这是非常

1687
00:28:37.171 --> 00:28:42.172
重要的，因为这里有一个

1689
00:28:42.172 --> 00:28:44.172
使用词法范围的标签过滤功能，它

1691
00:28:44.172 --> 00:28:47.172
取决于要打开的词法范围，

1693
00:28:47.172 --> 00:28:48.172
如果您不知道什么

1695
00:28:48.172 --> 00:28:50.172
是词法范围，那么我们不会去

1697
00:28:50.172 --> 00:28:51.172
现在开始讨论，但这只是关于

1699
00:28:51.172 --> 00:28:53.173
变量如何

1701
00:28:54.173 --> 00:28:57.173
保存在函数返回的这些函数中，

1703
00:28:57.173 --> 00:29:00.173
所以我们从这个函数返回一个过滤函数

1705
00:29:00.173 --> 00:29:02.174
我可以制作另一个关于它的视频，

1707
00:29:02.174 --> 00:29:04.174
因为这个函数

1709
00:29:04.174 --> 00:29:06.174
需要 所以无论你在哪里复制这段

1711
00:29:06.174 --> 00:29:07.174
代码，都要确保你在文件顶部有那一行

1713
00:29:07.174 --> 00:29:09.174
然后一切都应该

1715
00:29:09.174 --> 00:29:10.174
正常工作如果你对此有任何疑问

1717
00:29:10.174 --> 00:29:12.175
一定要在评论中留下注释

1719
00:29:12.175 --> 00:29:13.175
或者来找我不和谐

1721
00:29:13.175 --> 00:29:15.175
或 ifc 我会的 很高兴

1723
00:29:15.175 --> 00:29:15.175
向您解释

1725
00:29:16.175 --> 00:29:17.175
清楚，仅此而已 我希望您

1727
00:29:17.175 --> 00:29:19.175
喜欢这次关于

1729
00:29:20.175 --> 00:29:22.176
使用 org 漫游和 org 模式的更高级技巧的尝试

1731
00:29:22.176 --> 00:29:24.176
嗯，如果您喜欢我说的视频，

1733
00:29:24.176 --> 00:29:25.176
请留下一个赞并发表

1735
00:29:25.176 --> 00:29:27.176
评论，如果您喜欢 有任何问题，或者

1737
00:29:27.176 --> 00:29:29.176
如果您喜欢它，请告诉我，

1739
00:29:29.176 --> 00:29:30.176
直到下一次，非常感谢您的

1741
00:29:30.176 --> 00:29:30.176
收看和愉快的黑客攻击，我们会再见的
